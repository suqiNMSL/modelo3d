//
// m3d_drawable.js
// The drawable drawable. It is generated by merging lots of origianl scene elements
// with same rendering attributes.
//
//  

import Math         from "../../00utility/m3d_math.js";
import Node         from "../graph/m3d_node.js";
import Transform    from "./m3d_transform.js";


export default (function() {
    "use strict";

    function Drawable(name, mesh, layer, shader, material, transform, bbox) {
        // public:
        
        // Scene data
        this.name         = name; // The name of the model
        this.layer        = layer;

        // Rendering data
        this.mesh         = mesh; // The solid mesh
        this.material     = material;
        this.shader       = shader;
        this.transform    = new Transform(transform);
        
        // Visibility data
        this.visible      = (layer? layer.visible : true);
        this.bbox         = null;
        this.bsphere      = null;
        
        // Intermediate data
        this.distance     = 0; // The distance of drawable to eye.

        this.nodes        = []; // A drawable is composed of several nodes of scene graph
        this.hidables     = -1; // the index of starting element that can be hidable during camera rotation.
        
        // Initialization:
        if (this.material) {
            this.material.attachShader(this.shader);
        }

        if (bbox) {
            this.bbox = Math.aabb.createFromArray(bbox);
            this.bsphere = Math.sphere.createFromAABB(this.bbox);
        }
        this.isShadowReceiver = true;
    }; 

    Drawable.prototype.destroy = function() {
        this.transform.destroy();
        this.transform = null;
        delete this.transform;

        this.mesh     = null;
        this.material = null;
        this.layer    = null;
    };
    
    Drawable.prototype.isShadowCaster = function() {
        // Don't draw solid transparent objects in shadow generation. It can most
        // likely be the glass.
        return (!this.material.transparent ||
                this.material.parameters.hasOwnProperty("uMaterialDiffuseTexture")) &&
                this.mesh.isTriangle();
    };
    
    Drawable.prototype.isInstancing = function() {
        return false;
    };

    Drawable.prototype.setShader = function(shader) {
        if (this.shader !== shader) {
            this.shader = shader;

            this.material.attachShader(shader);
        }
    };

    // FIXME: multiply bbox with transform is not working as we want to transform
    // the drawable w.r.t. its initial position.
    //Drawable.prototype.setTransform = function(matrix) {
    //    Math.aabb.transform(this.bbox, this.bbox, matrix);
    //    this.bsphere = Math.sphere.createFromAABB(this.bbox);

    //    this.transform.setTransform(matrix);
    //};

    // Pick an element inside this drawable that intersects with pick ray. We can
    // assume the ray has already intersected with this drawable.
    Drawable.prototype.pickNode = function(point, direction, position, graph) {
        if (this.nodes.length === 0) {
            console.log("Error! The drawable has no scene information.");
            return null;
        }

        if (this.nodes.length === 1) {
            return this.nodes[0];
        }

        var minDistance = Number.MAX_VALUE;
        var closestNode = null;
        var bbox = [0, 0, 0, 0, 0, 0];
        for (var i = 0, len = this.nodes.length; i < len; ++i) {
            var node = this.nodes[i];

            graph.getNodeBBox(node.id, bbox);
            var intersect = null;
            if (Math.inside.point_aabb(position, bbox)) {
                intersect = Math.intersect.ray_aabb(point, direction, bbox);
            }

            if (intersect) {
                var dx = intersect[0] - point[0];
                var dy = intersect[1] - point[1];
                var dz = intersect[2] - point[2];

                var d = dx * direction[0] + dy * direction[1] + dz * direction[2];
                if (d < minDistance) {
                    minDistance = d;
                    closestNode = this.nodes[i];
                }
            }
        }

        return closestNode;
    };

    Drawable.prototype.updateVisibility = function() {
        // This drawable is single-noded. The visibility of node
        // equals the visibility of this drawable.
        if (this.nodes.length === 1) {
            this.visible = visible;
            return ;
        }

        var visible = 0;
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            if (this.nodes[i].visible) {
                visible++;
            }
        }

        if (visible === 0) {
            this.visible = false;
            return ;
        }
            
        this.visible = true;
        
        // Change the visibility attribute of the each vertex to reflect
        // the visibility change.
        var vertexSize = this.mesh._attributes.values[0].stride;
        var verticesCount = 0;
        var bufferOffset = 0;
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            var node = this.nodes[i];
            bufferOffset += node.verticesCount * vertexSize;
            verticesCount += node.verticesCount;
        }

        var verticesOffset = 0;
        var visibility = new Uint8Array(verticesCount);
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            var node = this.nodes[i];
            if (!node.visible) {
                var v = new Uint8Array(visibility.buffer, verticesOffset, node.verticesCount);
                for (var j = 0; j < node.verticesCount; j++) {
                    v[j] = 255;
                }
            }
            verticesOffset += node.verticesCount;
        }

        this.mesh.vbSubData(bufferOffset, visibility);
    };

    Drawable.prototype.setNodeMaterial = function(node, material) {
        if (this.material.index === material.index) {
            return ;
        }

        node.visible = visible;
        
        var verticesOffset = 0;
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            if (this.nodes[i] === node) {
                break;
            }
            verticesOffset += node.verticesBytes;
        }

        // Find the starting position of material IDs in the buffer.
        var vertexSize = this.mesh.attributes.values[0].stride + 1;
        var bufferOffset = verticesBytes + node.verticesBytes / vertexSize * this.mesh.attributes.values[0].stride;

        var materialIds = new Uint8Array(vertexSize);
        for (var i = 0; i < vertexSize; i++) {
            materialIds[i] = material.index;
        }
        this.mesh.update(bufferOffset, materialIds);
    };

    Drawable.prototype.render = function(camera, shader, indices) {
        this.transform.use(camera, shader);
        this.mesh.renderSub(indices[0], indices[1]);
    };


    return Drawable;
})();
    
